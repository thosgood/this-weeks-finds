<TITLE> week240 </TITLE>




<p>
I'm back from Shanghai, and classes are well underway now.  For the
last few weeks I'd been frantically preparing a talk for Stewart
Brand's &quot;Seminars About Long-Term Thinking&quot;, up in San
Francisco.  I talked about how we need to &quot;zoom out&quot; of our
short-term perspective to understand the history of the earth's
climate and what we're doing to it now:

<p>
1) John Baez, Zooming out in time, 
<a href = "http://math.ucr.edu/home/baez/zoom/">http://math.ucr.edu/home/baez/zoom/</a>

<p>
There's a lot of tricky physics in this business.  Consider, 
for example, this graph of cycles governing the Earth's precession, 
the obliquity of its orbit, and the eccentricity of its orbit:

<div align = center>
<img src = "Milankovitch_Variations.png">
</div>

<p>
2) Wikipedia, Milankovitch cycles, 
<a href = "http://en.wikipedia.org/wiki/Milankovitch_cycles">http://en.wikipedia.org/wiki/Milankovitch_cycles</a>

<p>
Here a &quot;kyr&quot; is a thousand years.  
The yellow curve combines information from all three of these cycles
and shows the amount of solar radiation at 65 degrees north latitude.
The bottom black curve shows the amount of glaciation.  As
Milankovitch's theory predicts, you can sort of see a correlation
between the yellow and black curves - but it's nothing simple or
obvious.  One reason is the complex feedback mechanisms within the
Earth's climate.

<p>
Here's a great place to read about this stuff:

<p>
3) Barry Saltzman, Dynamical Paleoclimatology: Generalized Theory of 
Global Climate Change, Academic Press, New York, 2002.

<p>
Anyway, now this talk is done, and I can focus more on teaching.

<p>
In my seminar this year, we're focusing on two topics: quantization
and cohomology, and classical versus quantum computation.  I'm
trying out something new: not only are the notes available on the 
web, there's also a blog entry for each class, where you can ask 
questions, make comments and correct my mistakes!

<p>
4) John Baez, Fall 2006 seminars: Quantization and cohomology, and
Classical versus quantum computation.  Notes by Derek Wise, homeworks
and blog entries available at
<a href = "http://math.ucr.edu/home/baez/qg-fall2006/">http://math.ucr.edu/home/baez/qg-fall2006/</a>

<p>
I hope more people blend teaching with blogging.  It's not too much work 
if someone with legible handwriting takes notes and the lectures can 
actually be followed from the notes.  You can use blogging to 
interactively teach people scattered all over the planet!

<p>
This week, James Dolan gave a talk on something he's been working on for 
a long time: games and cartesian closed categories.  Lately he's been 
working with Todd Trimble, and they reproved some important results in
a fun new way.  Let me sketch the ideas for you....

<p>
Let's play a game.  I have a set X in my pocket, and I'm not telling 
you what it is.  Can you pick an element of X in a systematic way?  

<p>
No, of course not: you don't have enough information.  X could even 
be empty, in which case you're clearly doomed!  But even if it's nonempty, 
if you don't know anything about it, you can't pick an element in a 
systematic way.  

<p>
So, you lose.

<p>
Okay, let's play another game.  Can you pick an element of 

<p>
X<sup>X</sup> 

<p>
in a systematic way?  Here A<sup>B</sup> means the set of functions
from B to A.  So, I'm asking if you can pick a function from X to
itself in a systematic way.

<p>
Yes!  You can pick the identity function!  This sends each element
of X to itself:

<p>
x |&rarr; x

<p>
You don't need to know anything about X to describe this function. 
X can even be empty.  

<p>
So, you win.  

<p>
Are there any other ways to win?  No.  

<p>
Now let's play another game.  Can you pick an element of 

<p>
X<sup>( X<sup>X</sup> )</sup>

<p>
in a systematic way?  

<p>
An element in here takes functions from X to itself and turns them into 
elements of X.  When X is the set of real numbers, people call this sort 
of thing a &quot;functional&quot;, so let's use that term.  A functional eats 
functions and spits out elements.

<p>
You can scratch your head for a while trying to dream up a systematic
way to pick a functional for any set X.  But, there's no way. 

<p>
So, you lose.

<p>
Let's play another game.  Can you pick an element of 

<p>
(X<sup>X</sup>)<sup>( X<sup>X</sup> )</sup>

<p>
in a systematic way?  

<p>
An element in here eats functions and spits out functions.  When X is
the set of real numbers, people often call this sort of thing an 
&quot;operator&quot;, so let's use that term.  

<p>
Given an unknown set X, can you pick an operator in a systematic
way?  Sure!  You can pick the identity operator.  This operator 
eats any function from X to itself and spits out the same function:

<p>
f |&rarr; f

<p>
Anyway: you win.

<p>
Are there any other ways to win?  Yes!  There's an operator that
takes any function and spits out the identity function:

<p>
f |&rarr; (x |&rarr; x)

<p>
This is a bit funny-looking, but I hope you get what it means: you
put in any function f, and out pops the identity function x |&rarr; x.

<p>
This arrow notation is very powerful.  It's usually called the 
&quot;&lambda; calculus&quot;, since when Church invented it in the 1930s, he 
wrote it using the Greek letter &lambda; instead of an arrow: instead of 

<p>
x |&rarr; y

<p>
he wrote

<p>
&lambda; x.y

<p>
But this just makes things more confusing, so let's not do it.

<p>
Are there more ways to win this game?  Yes!  There's also an operator
called &quot;squaring&quot;, which takes any function f from X to itself 
and &quot;squares&quot; it - in other words, does it twice.  If we write
the result as f<sup>2</sup>, this operator is

<p>
f |&rarr; f<sup>2</sup>

<p>
But, we can express this operator without using any special symbol
for squaring.  The function f is the same as the function

<p>
x |&rarr; f(x)

<p>
so the function f<sup>2</sup> is the same as

<p>
x |&rarr; f(f(x))

<p>
and the operator &quot;squaring&quot; is the same as

<p>
f |&rarr; (x |&rarr; f(f(x)))

<p>
This looks pretty complicated.  But, it shows that our systematic
way of choosing an element of 

<p>
(X<sup>X</sup>)<sup>( X<sup>X</sup> )</sup>

<p>
can still be expressed using just the &lambda; calculus.

<p>
Now that you know &quot;squaring&quot; is a way to win this particular game, 
you'll immediately guess a bunch of other ways: &quot;cubing&quot;, and so on.  
It turns out all the winning strategies are of this form!  We can 
list them all using the &lambda; calculus:

<p>
f |&rarr; (x |&rarr; x)

<p>
f |&rarr; (x |&rarr; f(x))

<p>
f |&rarr; (x |&rarr; f(f(x)))

<p>
f |&rarr; (x |&rarr; f(f(f(x))))

<p>
etc.  Note that the second one is just a longer name for the 
identity operator.  The longer name makes the pattern clear.

<p>
So far, all these methods of picking an element of 
(X<sup>X</sup>)<sup>( X<sup>X</sup> )</sup> for an unknown set X can be 
written using the &lambda; calculus.   There are other sneakier ways.  For 
example, there's the operator that sends functions with fixed 
points to the identity function, and sends functions without fixed 
points to themselves.  It's an interesting challenge to figure out all
these sneaky ways, but it's way too hard for me.   So, from now on, 
just to keep things simple, let's only consider &quot;systematic ways&quot;
that can be expressed using the &lambda; calculus.  To win one of my games,
you need to use the &lambda; calculus to pick an element of the set I write
down.

<p>
So, let's play another game.  Can you write down an element of

<p>
X <sup>( X<sup>( X<sup>X</sup> )</sup> )</sup>

<p>
using the &lambda; calculus?

<p>
An element in here eats functionals and spits out elements of X.  
So, it's called a &quot;functionalal&quot; on X.  At least that's what Jim
calls it.

<p>
If I have an unknown set in my pocket, can you write down functionalal 
on this set using the &lambda; calculus?

<p>
Yes!  You need to dream up a recipe that takes functionals on X
and turns them into elements of X.   Here's one recipe: take any 
functional and evaluate it on the <em>identity</em> function, getting
an element of x.  

<p>
In &lambda; calculus notation, this recipe looks like this:

<p>
f |&rarr; f(x |&rarr; x)

<p>
Can you think of other ways to win this game?  I hope so: there are 
infinitely many!  Jim and Todd figured out a systematic way to list
them all.

<p>
Now let's play another game.  Can you write down an element of 

<p>
X<sup>(X<sup>(X<sup>(X<sup>X</sup>)</sup>)</sup>)</sup>

<p>
using the &lambda; calculus?  The parentheses are getting a little obnoxious
by now, so let's adopt the convention that A<sup>B<sup>C</sup></sup>
is short for A<sup>(B<sup>C</sup>)</sup>, which lets us write the
above expression as

<p>
X<sup>X<sup>X<sup>X<sup>X</sup></sup></sup></sup>

<p>
A thing in here eats functionalals and spits out
elements of X, so it's called a &quot;functionalalal&quot;.  

<p>
So, can you write down a functionalalal on an unknown set using the
&lambda; calculus?

<p>
The answer is no: you lose.  

<p>
How about writing down an element of

<p>
((X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup>)<sup>((X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup>)</sup>

<p>
using the &lambda; calculus?  Such a thing eats operators and spits out operators,
so it's called an &quot;operatorator&quot;.  

<p>
The answer is yes: there are lots of ways to win this game.  The real
challenge is listing all of them!  This is the sort of question Dolan
and Trimble figured out the answer to - though as we'll see, they
weren't the first.

<p>
In fact, instead of moving on to functionalators, operatorals, 
operatoralatorals, and so on, let me just tell you trick for instantly 
deciding which of all these games you can win.

<p>
You just take your game, like this:

<p>
((X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup>)<sup>((X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup>)</sup>


<p>
and evaluate it by setting X = 0.  If you get 0, there's no way to 
win.  If you get 1, there's at least one way to win. 

<p>
To use this trick, you need to know that

<p>
0<sup>0</sup> = 1

<p>
This is something they don't teach in school!  In analysis, X<sup>Y</sup>
can approach anything between 0 and 1 when X and Y approach 0 from above.  
So, teachers like to say 0<sup>0</sup> is undefined.  
But X<sup>X</sup> approaches 1 when X &rarr; 0.  
More importantly, in set theory, A<sup>B</sup> stands for the set of functions 
from B to A, and the number of elements in this set is 

<p>
|A<sup>B</sup>| = |A|<sup>|B|</sup>

<p>
When A and B are empty, there's just one function from B to A, namely 
the identity.  So, for our purposes we should define 0<sup>0</sup> = 1.

<p>
Consider the case of functionals, which are elements of
X<sup>X<sup>X</sup></sup>.  If we evaluate this at X = 0 we get

<p>
0<sup>0<sup>0</sup></sup> = 0<sup>1</sup> = 0

<p>
So, there are no functionals when X is the empty set.  So, you can't 
pick a functional on a unknown set in <i>any</i> systematic way.  That's why
you lose when your game evaluates to 0.  It's more interesting to 
prove that for games evaluating to 1, there's a way to win, using
the &lambda; calculus.

<p>
But we'd really like to understand <em>all</em> the ways to win using
the &lambda; calculus.  And for this,
Dolan and Trimble used the theory of holodeck games.  

<p>
In Star Trek, the &quot;holodeck&quot; is a virtual reality environment where 
you can play various games:  

<p>
<div align = center>
<a href = "http://www.startrek.com/startrek/view/library/technology/article/105222.html">
<img src = "holodeck.jpg">
</a>
</div>
<p>

On the holodeck, if you regret a move you made, you can back up to any
earlier point in the game and make a new move.

<p>
Actually I'm deviating from the technical specifications of the
holodeck on Star Trek, as explained here:

<p>
6) Wikipedia, Holodeck, <a href = "http://en.wikipedia.org/wiki/Holodeck">http://en.wikipedia.org/wiki/Holodeck</a>

<p>
So, if you're a Star Trek purist, it's better to imagine a video 
game where you can save your game at any state of play, and 
go back to these saved games whenever you want.  
And, you have to imagine being so paranoid that you <em>always</em> 
save your game before making a move.  This allows games to go on forever,
so we only say you have a winning strategy if you can win in a finite 
number of moves, no matter what the other player does.

<p>
To make this completely precise, we consider two-player games where the
players take turns making moves.  When a player can't make a move,
they lose.  Any such game can be written as a &quot;game tree&quot;, like this:

<pre>
     | \/ 
   \ | /
    \|/ 
</pre>
In this example, the first player has three choices for her first move.
If she picks the middle branch, the second player has one choice for his
first move.  Then the first player has one choice for her second move.
Then the second player has no choice for his second move - so he loses.

<p>
So, in this particular example the second player has no winning strategy.

<p>
A cool thing about such a game is that we can take its game tree and
turn it into an expression built from some variable X using products 
and exponentials.  To do this, just put an X at each vertex of the tree 
except the root:

<pre>
     X  X  X 
     |   \/ 
 X   X   X
  \  |  /
   X X X
    \|/ 
</pre>

Then blow on the tree with a strong westerly wind, so strong that the
branches blow away and only the X's are left:

<pre>
        X   XX
   X   X   X
  X   X   X 
</pre>
This is just a way of writing an expression built from X using products and
exponentials: 

<p>
X<sup>X</sup> X<sup>X<sup>X</sup></sup> X<sup>X<sup>XX</sup></sup>

<p>
Conversely, any such expression can be turned back into a tree, at least 
after we simplify it using these rules:

<p>
(AB)<sup>C</sup> = A<sup>C</sup> B<sup>C</sup>

<p>
(A<sup>B</sup>)<sup>C</sup> = A<sup>BC</sup>

<p>
For example, consider the set of operators:

<p>
(X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup> 

<p>
If we simplify this, we get

<p>
X<sup>X X<sup>X</sup></sup>

<p>
or

<pre>
     X
  X X
 X
</pre>
giving the tree

<pre>
        X
       /
  X   X
   \ / 
    X
    |
</pre>
or in other words

<pre>
      /
   \ /
    |
</pre>
And here's a cool fact: if you take any expression built from X
using products and exponentials, and evaluate it at X = 0, you can 
tell which player has a winning strategy for the game described by 
the corresponding tree!  If you get 1, the second player has a winning
strategy; if you get 0, they don't.

<p>
It's pretty easy to prove: try it.

<p>
But if you've been paying attention, you'll have noticed something weird. 

<p>
I've told you <em>two</em> ways to get a game from any expression built from X 
using products and exponentials.  First, the game of defining 
an element of the resulting set, using the &lambda; calculus.
Second, the game we get by 
turning this expression into a game tree, like I just did.

<p>
For <em>both</em> these games, you can decide if there's a winning 
strategy by evaluating the expression at X = 0.  

<p>
But are they the same game?  No!  One is the holodeck version of the other!

<p>
Let's look at the familiar example of operators:

<p>
(X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup> = X<sup>X X<sup>X</sup></sup>

<p>
This evaluates to 1 at X = 0.  So, if we turn it into a tree

<pre>
      /
   \ /
    |
</pre>
we get a game where the second player has a winning strategy.

<p>
This game is not very exciting, but it becomes more exciting if you 
call it &quot;The Lady or the Tiger&quot;.  In this game, the first player
has only one first move: he takes the second player to a room 
with two doors, corresponding to the two branches of the above tree.  

<p>
Then it's the second player's turn.  

<p>
If he opens the left door, a beautiful lady pops out and they instantly 
get married and live happily ever after.  If he opens the right door, 
the first player opens a tiger cage.  Then the tiger jumps out and eats
the second player.

<p>
In this game, the second player has just <em>one</em> winning strategy: 
on his first move he should choose the left door.

<p>
Next look at the game of defining an element of 

<p>
(X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup> = X<sup>X X<sup>X</sup></sup>

<p>
using the &lambda; calculus.  We've seen there are <em>infinitely many</em>
strategies for winning this:

<p>
f |&rarr; (x |&rarr; x)

<p>
f |&rarr; (x |&rarr; f(x))

<p>
f |&rarr; (x |&rarr; f(f(x)))

<p>
f |&rarr; (x |&rarr; f(f(f(x))))

<p>
and so on.  These correspond to 2nd-player winning strategies 
for the <em>holodeck version</em> of The Lady or the Tiger.

<p>
What are these strategies?  

<p>
One is just to play the game and win by choosing the left door.

<p>
Another is to choose the right door - and then, just when the 
tiger is about to eat you, back up and choose the left door!

<p>
Another is to choose the right door - and then, just when the 
tiger is about to eat you, back up and choose... the right door!

<p>
<div align = center>
<a href = "http://en.wikipedia.org/wiki/D%27oh">
<img src = "D_oh.jpg">
</a>
</div>
</p>


Then, when the tiger is about to devour you again, back 
up again, and this time choose the left door.  

<p>
And so on: for each n, there's a strategy where you choose the
right door n times before wising up and choosing the left door. 

<p>
Now, if you want a really nice math project, ponder the pattern 
relating all these strategies to the corresponding &lambda; calculus 
expressions:

<p>
f |&rarr; (x |&rarr; x)

<p>
f |&rarr; (x |&rarr; f(x))

<p>
f |&rarr; (x |&rarr; f(f(x)))

<p>
f |&rarr; (x |&rarr; f(f(f(x))))

<p>
Then, figure out how to prove that for <em>any</em> 2-person game, say:

<pre>
     | \/ 
   \ | /
    \|/ 
</pre>
there's a 1-1 correspondence between winning second-person strategies
for the holodeck verson of this game and ways of using the &lambda;
calculus to define elements of the corresponding set:

<p>
X<sup>X</sup> X<sup>X<sup>X</sup></sup> X<sup>X<sup>XX</sup></sup>

<p>
Apparently this result goes back to work of Hyland and Ong in the
early 1990s.  Dolan rediscovered the idea, and Trimble and he have
recently worked out a new proof.  

<p>
If you get stuck proving this result yourself, first try these notes
from Dolan's talk, for some hints:

<p>

7) James Dolan, Holodeck strategies and cartesian closed categories,
lecture at UCR, notes by John Baez, Oct. 19, 2006, available at
<a href = "http://math.ucr.edu/home/baez/qg-fall2006/f06week03b.pdf">http://math.ucr.edu/home/baez/qg-fall2006/f06week03b.pdf</a>

<p>
Then try Trimble's more rigorous, technical treatment, and the
original paper by Hyland and Ong:

<p>
8) Todd Trimble, Holodeck games and CCCs, available at
<a href = "http://math.ucr.edu/home/baez/trimble/holodeck.html">http://math.ucr.edu/home/baez/trimble/holodeck.html</a>

<p>
9) Martin Hyland and C.-H. Luke Ong, On full abstraction for PCF,
Information and Computation, 163 (2000), 285-408. Also available at <a href =
"ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Luke.Ong/pcf.ps.gz">ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Luke.Ong/pcf.ps.gz</a>

<p>

Dolan's talk also explains some other fun stuff, like how to multiply
and exponentiate games.  So, if you read these notes, you'll learn how
to play

<p>
          chess &times; go
<p>
and 

<p>
          chess<sup>go</sup>

<p>
at least after chess and go have been &quot;improved&quot; so games never last
forever and the last player able to make a move wins.

<p>
But, if you're planning to study this stuff, I'd better admit right 
now that Dolan and Trimble make heavy use of the relation between the
&lambda; calculus and cartesian closed categories.

<p>
A category is &quot;cartesian&quot; if it has finite products - or in
other words, binary products and a terminal object.  It's
&quot;cartesian closed&quot; if it also has exponentials.  All these
terms are carefully defined in the week 2 and week 3 notes of my
classical versus quantum computation course, so let me just illustrate
them with an example: the category of sets.  Here the product A
&times; B of two sets A and B is their usual Cartesian product.  The
exponential A<sup>B</sup> is the set of functions from B to A.  Any
1-element set is a terminal object.

<p>
Dolan and Trimble don't really talk about an unknown set X, as I did
above.  What they really study is the &quot;free cartesian closed
category on one object x&quot;, which I like to call CCC[x].  Any
object in CCC[x] is built from the object x by means of binary
products, exponentials and the terminal object.  For example, we have
objects like this:

<p>
x<sup>1</sup> 1<sup>x<sup>x</sup></sup> (x x)<sup>x 1 x<sup>x<sup>x</sup></sup></sup>

<p>
where I've omitted the times symbols for products.  

<p>
However, every object is isomorphic to one in &quot;tree form&quot;.
For example, the above object is isomorphic to

<p>
x x<sup>x x<sup>x<sup>x</sup></sup></sup> x<sup>x x<sup>x<sup>x</sup></sup></sup> 

<p>
which we can draw as a tree:

<pre>
   x     x
   |    /
 x x x x 
  \| |/  
 x x x   
  \|/    
</pre>
Dolan and Trimble consider the set of elements of any object in CCC[x], 
where an &quot;element&quot; is a morphism from the terminal object, e.g.

<p>
f: 1 &rarr; x x<sup>x x<sup>x<sup>x</sup></sup></sup> x<sup>x x<sup>x<sup>x</sup></sup></sup> 

<p>
And, they show these elements are in 1-1 correspondence with second-player
winning strategies for the holodeck version of the game whose tree is 
constructed as above.

<p>
If we pick any set X, the universal property of CCC[x] gives a functor

<p>
F: CCC[x] &rarr; Set

<p>
This maps elements of any object in CCC[x] to elements of the corresponding
object in Set:

<p>
F(f): 1 &rarr; X X<sup>X X<sup>X<sup>X</sup></sup></sup> 
X<sup>X X<sup>X<sup>X</sup></sup></sup> 

<p>
So, the element f gives a systematic way of picking elements of 
any set built from any arbitrary set X using finite products and 
exponentials.  

<p>
By the way, in a cartesian closed category, there's a 1-1 correspondence 
between morphisms

<p>
f: B &rarr; A

<p>
and elements

<p>
f: 1 &rarr; A<sup>B</sup>

<p>
So, one can use games to describe <em>all</em> the objects and
morphisms in the free cartesian closed category on one object!  One
can also describe <em>composition</em> of morphisms using games.  
In short, there's a complete description of CCC[x] in terms of games.

<p>
Now let me give you some references on cartesian closed categories, the
&lambda; calculus, categorical semantics, and games.  It's an interesting
network of subjects.

<p>
Categorical semantics was born in Lawvere's celebrated 1963 thesis on
algebraic theories:

<p>
10) F. William Lawvere, Functorial Semantics of Algebraic Theories,
Dissertation, Columbia University, 1963.  Also available at
<a href = "http://www.tac.mta.ca/tac/reprints/articles/5/tr5abs.html">http://www.tac.mta.ca/tac/reprints/articles/5/tr5abs.html</a>

<p>
Semantics deals with theories and their models.  Dual to the concept
of semantics is the concept of &quot;syntax&quot;, which deals with
proofs.  In the case of algebraic theories, the syntax was studied
before Lawvere in the subject called &quot;universal algebra&quot;:

<p>
11) Stanley Burris and H.P. Sankappanavar, A Course in Universal 
Algebra, available at <a href = "http://www.math.uwaterloo.ca/~snburris/htdocs/ualg.html">http://www.math.uwaterloo.ca/~snburris/htdocs/ualg.html</a>

<p>
Lawvere modernized universal algebra by realizing that an algebraic
theory is just a cartesian category, and a model is a
product-preserving functor from this theory into Set or some other
cartesian category - hence his thesis title, &quot;Functorial
Semantics&quot;.  I explained this in much more detail back in <a href
= "week200.html">week200</a>.

<p>
The relevance of all this to computer science becomes visible when we
note that a proof in universal algebra can be seen as a rudimentary
form of computation.  The &quot;input&quot; of the computation is a
set of assumptions, while the &quot;output&quot; is the equation to be
proved.

<p>
Treating proofs as computations may seem strained, but it becomes less 
so when we move to richer formalisms which allow for more complex logical 
reasoning.  One of best-known of these is the &lambda; calculus, invented 
by Church and Kleene in the 1930s as a model of computation.  Any function 
computable by the &lambda; calculus is also computable by a Turing machine, 
and according to the Church-Turing thesis these are all the functions 
computable by any sort of systematic process.  Moreover, computations in 
the &lambda; calculus can actually be seen as proofs.

<p>
The usefulness of this way of thinking was brought out in Landin's 
classic paper:

<p>
12) P. Landin, A correspondence between ALGOL 60 and Church's
&lambda;-notation, Comm. ACM 8 (1965), 89-101, 158-165.

<p>
This began a long and fruitful line of research - see for example this:

<p>
13) H. Barendregt, The Lambda Calculus, its Syntax and Semantics, 
North-Holland, 1984.

<p>
The power of the &lambda; calculus is evident in the textbook developed for 
MIT's introductory course in computer science, which is available online:

<p>
14) H. Abelson, G. J. Sussman and J. Sussman, Structure 
and Interpretation of Computer Programs, available at 
<a href = "http://www-mitpress.mit.edu/sicp/">
http://www-mitpress.mit.edu/sicp/</a>

<p>
It cites pioneers like Haskell Curry, and it even has a big &quot;&lambda;&quot;
on the cover!

<p>
<div align = center>
<img src = "http://www-mitpress.mit.edu/sicp/graphics/main-banner.gif"
alt = "wizard book"/>
</div>
</p>

<p>
Students call it &quot;the wizard book&quot;, because the cover also
features a picture of a wizard.  It's used at over 100 colleges and
universities, and it has spawned a semi-mythical secret society called
The Knights of the Lambda Calculus, whose self-referential emblem
celebrates the ability of the &lambda; calculus to do recursion:

<p>

<div align = center>
<img src =
"http://content.answers.com/main/content/wp/en/d/d2/Lambda.png"
alt="lambda"/>
</div>
</p>

<p>
In 1980, Lambek made a great discovery:

<p>
15) Joachim Lambek, From lambda calculus to Cartesian closed categories, 
in To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus
and Formalism, eds. J. P. Seldin and J. Hindley, Academic Press, 1980, 
pp. 376-402.

<p>
He showed that just as algebraic theories can be regarded as cartesian
categories, theories formulated in the &lambda; calculus can be regarded
as cartesian closed categories (or CCCs, for short).  

<p>
Lambek's discovery introduced a semantics for the &lambda; calculus, since 
it lets us to speak of &quot;models&quot; of theories formulated in the &lambda; 
calculus, just as we could for algebraic theories.  In computer programming, 
the importance of a model is that it gives a picture of what a program
actually accomplishes.  A model in the category of Sets, for example,
sends any program to an actual function between sets.

<p>
There's no way to list all the interesting references to CCCs and the
&lambda;-calculus, but here are some online places to get going on them,
starting out easy and working up to the harder ones.  This Wikipedia
article is quite good:

<p>
16) Wikipedia, Lambda calculus, available at 
<a href = "http://en.wikipedia.org/wiki/Lambda_calculus">http://en.wikipedia.org/wiki/Lambda_calculus</a>

These blog entries by Mark Chu-Carroll are <i>lots</i> of fun - just
the kind of readable, informal exposition I aspire to:

<p>
17) Mark Chu-Carroll, Lambda calculus, available at 
<a href = "http://goodmath.blogspot.com/2006/06/lamda-calculus-index.html">http://goodmath.blogspot.com/2006/06/lamda-calculus-index.html</a>

<p>
Mark Chu-Carroll, Category theory, available at 
<a href = "http://scienceblogs.com/goodmath/goodmath/category_theory/">http://scienceblogs.com/goodmath/goodmath/category_theory/</a>

<p>
These go deeper:

<p>
18) Peter Selinger, Lecture notes on the lambda calculus, available
at <a href = "http://www.mscs.dal.ca/~selinger/papers.html#lambdanotes">http://www.mscs.dal.ca/~selinger/papers.html#lambdanotes</a>

<p>
and deeper:

<p>
19) Phil Scott, Some aspects of categories in computer science, 
available at <a href = "http://www.site.uottawa.ca/~phil/papers/handbook.ps">http://www.site.uottawa.ca/~phil/papers/handbook.ps</a>

<p>
and here's a classic:

<p>
20) Joachim Lambek and Phil Scott, Introduction to Higher Order 
Categorical Logic, volume 7 of Cambridge Studies in Advanced Mathematics, 
Cambridge U. Press, 1986.

<p>
Dolan and Trimble are far from the first to study the relation between
games and categories.  In the 1970s, Conway invented a wonderful
theory of games and surreal numbers:

<p>
21) John H. Conway, On Numbers and Games, Academic Press, New York, 1976.
Second edition: A. K. Peters, Wellesley, Massachusetts, 2001.

<p>
22) Elwyn Berlekamp, John H. Conway, Richard Guy, Winning Ways, vols. 1-2,
Aadmic Press, New York, 1982.  Second edition, vols. 1-4, A. K. Peters, 
Wellelsey, Massachusetts, 2001-2004.

<p>
23) Dierk Schleicher and Michael Stoll, An introduction to Conway's games
and numbers, available as <a href = "http://arxiv.org/abs/math.CO/0410026">math.CO/0410026</a>.

<p>
In 1977, Joyal modified Conway's work a bit and related it explicitly
to category theory:

<p>
24) Andr&eacute; Joyal, Remarques sur la theorie des jeux a deux personnes,
Gazette des Sciences Mathematiques du Quebec, Vol I no 4 (1977), 46-52.

<p>
For an online version in English, try:

<p>
25) Andr&eacute; Joyal, trans. Robin Houston, Remarks on the theory of
two-person games, 2003.  Available at <a href =
"http://www.ma.man.ac.uk/~rhouston/Joyal-games.ps">http://www.ma.man.ac.uk/~rhouston/Joyal-games.ps</a>

<p>
I don't know the subsequent history very well - I'm no expert on any
of this stuff! - but by 1990 Martin Hyland was giving lectures on
Conway games and logic.  In 1992, Andreas Blass published an
influential paper on &quot;game semantics&quot; for logic, where
propositions are interpreted as games and winning
strategies are proofs:  

<p>
26) Andreas R. Blass, Game semantics and linear logic, Annals of Pure 
and Applied Logic 56 (1992), 183-220.  

<p>
Then came these important papers:

<p>
27) Samson Abramsky and Radha Jagadeesan, Games and full completeness 
for multiplicative linear logic, Journal of Symbolic Logic, 59 (1994),
543 - 574.   Also available at <a href = "http://citeseer.ist.psu.edu/564168.html">http://citeseer.ist.psu.edu/564168.html</a>

<p>
28) Martin Hyland and C.-H. Luke Ong, Fair games and full completeness 
for multiplicative linear logic without the MIX-rule, available at
<a href = "http://citeseer.ist.psu.edu/hyland93fair.html">http://citeseer.ist.psu.edu/hyland93fair.html</a>

<p>
According to Samson Abramsky,

<blockquote>
     After these results, it was clear that the most notorious issue
     in programming language semantics, the &quot;full abstraction problem
     for PCF&quot;, was in range. Remarkably enough, two different teams: 
<ul>
<li>      Abramsky, Jagadeesan and Malacaria 
</li>
<li>
     Hyland and Ong 
</li>
</ul>

     produced really quite different constructions which yielded in
     the end the same result: a synthetic construction of the fully
     abstract model.  (The technical issue in both cases was how to
     accomodate the linear exponentials, i.e. the possibility to copy and
     delete inputs to functions.  It turned out there are two very
     different approaches which can be taken.  The HO approach (also
     independently found by Hanno Nickau, incidentally) is quite related 
     to the ideas of the Lorenzen school, but, crucially, done
     compositionally. The AJM approach is related to the Geometry of
     Interaction - but takes the quite demanding step of making an
     honest CCC out of it.)
   
<p>
     After that, the next key step was to see that the whole space of
     programming languages and computational features opened up to a game
     theoretic analysis in a very systematic way, by varying the conditions
     on strategies.  This step was taken by myself and my students, and has
     led to a substantial further development.  More recently, Luke
     Ong, Dan Ghica, Andrzej Murawski and myself have developed algorithmic
     game semantics, as a basis for compositional program analysis and
     verification, and - in Luke and Andrzej's hands - as a beautiful
     meeting point between semantics and algorithmics.

<p>
     There have of course been many other developments too, and many
     people have contributed. There have been recent workshops on these
     topics, e.g. in Seattle as part of the Federated Logic Conference 
     in August.
</blockquote>

&quot;PCF&quot; is a souped-up version of the typed &lambda; calculus
that allows one to do arithmetic and full-fledged computation.  Here
are the papers on PCF mentioned above:

<p>
29) Samson Abramsky, R. Jagadeesan, and P. Malacaria, Full abstraction
for PCF, Information and Computation, 163 (2000), 409-470.  Available at
<a href = "http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/pubs.html">http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/pubs.html</a>

<p>
30) Martin Hyland and C.-H. Luke Ong, On full abstraction for PCF, In
Information and Computation 163 (2000), 285-408.  

<p>
Luke Ong has also written other papers using game theory to study
the &lambda; calculus:

<p>
31) A. D. Ker, H. Nickau, and C.-H. Luke Ong, A universal innocent
game model for the B&ouml;hm tree &lambda; theory, in Computer
Science Logic: Proceedings of the 8th Annual Conference on the
EACSL Madrid, Spain, September 1999, LNCS Volume 1683,
Springer-Verlag, 1999, pp. 405-419.

<p>
32) A. D. Ker, H. Nickau, and C.-H. Luke Ong, 
Innocent game models of untyped &lambda;-calculus,
Theoretical Computer Science, 272 (2002), 247-292. 

<p>
For a good introduction to all this work, try these:

<p>
33) Robin Houston, Categories of Games, M.Sc. thesis, U. Manchester, 2003.
Available at <a href = "http://www.cs.man.ac.uk/~houstorx/msc.pdf">http://www.cs.man.ac.uk/~houstorx/msc.pdf</a>

<p>
Robin Houston, Mathematics of Games, continuation report, U. Manchester, 
2004.  Available at <a href = "http://www.cs.man.ac.uk/~houstorx/continuation.pdf">http://www.cs.man.ac.uk/~houstorx/continuation.pdf</a>

<p>
Finally, for more on categories, intuitionistic logic, and linear logic,
see &quot;<a href = "week227.html">week227</a>&quot;.  


<P>
<P>
<HR>
<p>
<b>Addenda:</b> I thank Samson Abramsky, James Dolan, Dominic Hughes,
Tom Payne, Esa Peuha and Vaughn Pratt for helpful corrections.  When I
wrote the first version of this Week's Finds, I was ignorant of work
before Dolan and Trimble's that also described the free cartesian
closed category on one object in terms of games.  In addition to Abramsky's
corrections (some of which are above), I was gently set
straight by Dominic Hughes, who has permitted me to attach this post
of his from the category theory mailing list:

<blockquote>
<pre>
This "backtracking game" characterisation has been known since around
'93-'94, in the work of Hyland and Ong:

  M. Hyland and L. Ong. On full abstraction for PCF.  Information and
  Computation, Volume 163, pp. 285-408, December 2000. [Under review for
  6 years!]
  <a href = "ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Luke.Ong/pcf.ps.gz">ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Luke.Ong/pcf.ps.gz</a>

(PCF is an extension of typed &lambda; calculus.)  My D.Phil. thesis
extended the &lambda; calculus (free CCC) characterisation to second-order,
published in:

  Games and Definability for System F. Logic in Computer Science, 1997
  <a href = "http://boole.stanford.edu/~dominic/papers/">http://boole.stanford.edu/~dominic/papers/</a>

To characterise the free CCC on an <em>arbitrary</em> set {Z,Y,X,...} of
generators (rather than a single generator, as you discuss), one simply
adds the following Copycat Condition:

  (*) Whenever first player plays an occurrence of X, the second player
      must play an occurrence of X.

[Try it: see how X &rarr; Y &rarr; X has just one winning strategy.] Although the
LICS'97 paper cited above appears to be the first place the Copycat
Condition appears in print, I like to think it was already understood at
the time by people working in the area.  Technically speaking, winning
strategies correspond to &eta;-expanded &beta;-normal forms.  See pages 5-7 of
my thesis for an informal description of the correspondence.

It sounds like you've reached the point of trying to figure out how
composition should work.  Proving associativity is fiddly.  Hyland and
Ong give a very elegant treatment, via a larger CCC of games in which
<em>both</em> players can backtrack.  The free CCC subcategory is carved 
out as the so-called <em>innocent</em> strategies.  This composition is 
almost identical to that presented by Coquand in:

  A semantics of evidence for classical arithmetic.  Thierry Coquand.
  Proceedings of the CLICS workshop, Aarhus, 1992.

Dominic

PS A game-theoretic characterisation with an entirely different flavour
(winning strategies less "obviously" corresponding to &eta;-long &beta;-normal
forms) is:

  Abramsky, S., Jagadeesan, R. and Malacaria, P., Full Abstraction for
  PCF.  Info. &amp; Comp. 163 (2000), 409-470.
  <a href = "http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/pcf.pdf">http://web.comlab.ox.ac.uk/oucl/work/samson.abramsky/pcf.pdf</a>
  [Announced concurrently with Hyland-Ong, around '93-'94.]
</pre>
</blockquote>

On a different subject, James Dolan had this to say:

<blockquote>
you describe holodeck strategies for "lady or tiger" where you take
back "just when the tiger is about to eat you", but that's not the way
it works.  you take back just _after_ the tiger has eaten you.

<p>
(i guess that this is partially because of your lack of experience
with computer games with a "saved game" feature.  typically you die in
the game and the computer plays some sort of funeral or at least
funereal music; then you're taken to the reincarnation gallery where
you select one to return to from your catalog of previous lives.  or
something like that.)
</blockquote>

<p>
In the first version of this Week's Finds I claimed
that all systematic ways of picking an element of
(X<sup>X</sup>)<sup>(X<sup>X</sup>)</sup> could be defined using
the &lambda; calculus.  I was disabused of this notion by Vaughan Pratt,
who wrote:

<blockquote>
Hi, John, 

<p>
In &quot;week240&quot;, you said

<PRE>
  The moral of this game is that all systematic methods for picking
  an element of (X^X)^(X^X) for an unknown set X can be written
  using the &lambda; calculus.
</PRE>

What is unsystematic about the contagious-fixpoint functional?  This is the
functional that maps those functions that have any fixpoints to the identity
function (the function that makes every element a fixpoint) and functions
without fixpoints to themselves (thus preserving the absence of fixpoints).
It's a perfectly good functional that is equally well defined for all sets
X, its statement in no way depends on X, and conceptually the concept of
contagious fixpoints is even intuitively natural, but how do you write it
using the &lambda; calculus?

<p>
Many more examples in this vein at JPAA 128, 33-92 (Pare and Roman,
Dinatural numbers, 1998).  The above is the case K = {0} of Freyd's 
(proper) class of examples.

<p>
Vaughan
</blockquote>

Here Pratt uses &quot;functional&quot; to mean what I was calling an
&quot;operator&quot;.

<p>
For more discussion, go to the <a href = "http://golem.ph.utexas.edu/category/2006/10/this_weeks_finds_in_mathematic_1.html"><em>n</em>-Category
Caf&eacute;</a>.

<p>
<hr>
<em>Unlike chess or astrology, mathematics has the curious property of 
being an intellectual game that really matters.</em> - Rudy Rucker

<p>
<HR><P>

