<TITLE> week185 </TITLE>






<P>
I'd like to continue the story of &quot;q-mathematics&quot; which I was
telling you in &quot;<A HREF = "week183.html">week183</A>&quot; and
&quot;<A HREF = "week184.html">week184</A>&quot;.  Sorry for the
enormous pause - I was travelling around a bunch.

<P>
Let's see... where were we?  We were talking about &quot;q-deformation&quot; - 
a method of systematically modifying vast tracts of math and physics by
introducing a new parameter &quot;q&quot;, in such a way that everything reduces
to stuff you already knew when q = 1.

<P>
First we talked about the q-derivative:

<PRE>
              f(qx) - f(x)
              ------------
                 qx - x
</PRE>
and how we can reinvent mathematics by replacing the ordinary
derivative with this gadget: modifying the commutation relations in
quantum mechanics, replacing groups by quantum groups, and so on.  
I didn't say too much about this, but there's a lot to say.  Here's a
good place to get started:

<P>
1) Yu. I. Manin, Quantum Groups and Noncommutative Geometry, Les
Publ. du Centre de Recherches Math., Universite de Montreal, Montreal,
1988.

<P>
Next we took an idiosyncratic detour into &quot;q-arithmetic&quot;.  We
started with the q-integers:

<PRE>
[n] = 1 + q + ... + q<sup>n-1</sup>
</PRE>
which show up first from the fact that the q-derivative of x<sup>n</sup> is 

<PRE>
               (qx)<sup>n</sup> - x<sup>n</sup>
              ------------ = [n] x<sup>n-1</sup>
                 qx - x
</PRE>
From these we built q-factorials and q-binomial coefficients, and saw
that these functions arise naturally from &quot;q-deforming&quot;
combinatorics.  In ordinary combinatorics, you count structures on sets.
In q-deformed combinatorics, you instead count structures on projective
spaces over the field with q elements, F<sub>q</sub>.  All the formulas look the
same, except that wherever you had integers, you need to carefully
replace them by q-integers!

<P>
We also saw that by taking these formulas and setting q = -1 and q = 1, 
we can calculate the Euler characteristics of some projective varieties 
defined over the real and complex numbers.  

<P>
So: certain bits of combinatorics, projective geometry over finite
fields, and real or complex projective geometry are all somehow part
of a unified theory.  We can prove theorems simultaneously for all
these subjects and then specialize to the case we want just by setting
q to the right value.  It's sort of like tuning to whatever radio
station you want by turning the dial.  It's even good to tune q to 
be complex, when we're studying quantum groups... but I don't feel like
listening to those stations right now!  Right now I want to ponder 
the basics a bit more.  Like: what does all this have to do with quantum 
mechanics?

<P>
In &quot;<A HREF = "week183.html">week183</A>&quot; I described how to q-deform the &quot;Schroedinger
representation&quot; of a quantum particle on a line, in which its state is
described by a wavefunction.  The basic idea was to leave the position
operator alone, but replace the derivative in the momentum operator by
a q-derivative.

<P>
However, there's another way to describe a quantum particle on the
line, called the &quot;Fock representation&quot;.  Here we have an abstract
basis of states |0&gt;, |1&gt;, |2&gt;, ... where secretly we think of |n&gt; as
the nth eigenstate of the harmonic oscillator Hamiltonian.  There are
annihilation and creation operators a and a* which push us up and down
this ladder of states.  We can describe these very efficiently if
we think of states as being polynomials, with

<PRE>
|n&gt; = x<sup>n</sup> / n!
</PRE>
In these terms, the creation operator a* is just multiplication by x,
while the annihilation operator a is differentiation.  These satisfy
<PRE>
 a|n&gt;  =        |n-1&gt;
a*|n&gt;  =  (n+1) |n+1&gt;
</PRE>
so we get the commutation relations
<PRE>
a a* - a* a = 1 
</PRE>
In case you're wondering, my conventions differ slightly from the
usual ones, because my states |n&gt; aren't normalized - but there's a
good reason for this, which will become clear in due course.  

<P>
We can define other operators starting from the annihilation and
creation operators.  First, there's the harmonic oscillator Hamiltonian:

<PRE>
H = a* a
</PRE>
As you can easily check for yourself, it has our nice basis of states 
as eigenvectors:

<PRE>
H|n&gt; = n |n&gt;
</PRE>
It's also called the &quot;number operator&quot;, because its eigenvalue in the
nth state is just n.

<P>
Next, we can define position and momentum operators Q and P by:
      
<PRE>
        (a + a*) 
Q =    ----------
         sqrt(2)


        (a - a*) 
P =    ----------
        sqrt(2) i
</PRE>
It's easy to check that they satisfy the same commutation relations

<PRE>
PQ - QP = -i
</PRE>
as in the Schrodinger representation.  To get a full-blown isomorphism
between the Fock and Schrodinger representations, we just need to map
the state |0&gt; to a wisely chosen Gaussian function on the line, and
the rest falls into place....

<P>
But anyway, having already q-deformed the Schroedinger representation,
let's q-deform the Fock representation.  It's pretty simple: we leave
the creation operator alone, but use the q-derivative as our annihilation
operator!  This gives the q-deformed commutation relations:

<PRE>
a a* - q a* a = 1
</PRE>
If we now define a basis of states by 

<PRE>
|n&gt; = x<sup>n</sup> / [n]!
</PRE>
we get 
<PRE>
 a|n&gt;  =        |n-1&gt;
a*|n&gt;  =  [n+1] |n+1&gt;
</PRE>
We can also define a q-deformed Hamiltonian by

<PRE>
H = a* a
</PRE>
and we get

<PRE>
H|n&gt; = [n] |n&gt;
</PRE>
so we could call this operator the &quot;q-number operator&quot;.  

<P>
We could march on like this, but now I want to take a quantum leap.   
If we &quot;categorify&quot; the ordinary Fock representation, we get the
combinatorics of structures on finite sets.  And if we categorify the
q-deformed Fock representation, we get the combinatorics of structures
on projective spaces over the field with q elements!

<P>
Let me explain....

<P>
Ordinary combinatorics counts structures on finite sets.  It's fun to do
this using &quot;generating functions&quot;.  To do this, suppose we have some
type of structure that we can put on a finite set - like an ordering, or
a partition, or a way of coloring the set, or making it into a graph of
some sort, or whatever: anything we might want to count!  Let's call
this type of structure F, and let F<sub>k</sub> stand for the set of all ways we
can put this structure on a k-element set, and let |F<sub>k</sub>| 
be the <em>number</em>
of all ways we can put this structure on a k-element set.  Then we can
define a function |F| by

<PRE>
               |F<sub>k</sub>| 
|F|(x) =   &sum;  -----  x<sup>k</sup>
                k!
</PRE>
This is called the &quot;generating function&quot; of F.  Of course, the sum
might not converge; it's really just a formal power series.

<P>
For example, suppose F is &quot;2-colorings&quot; - to put a structure
like this on a finite set, we color each element either red or blue.
There are 2<sup>k</sup> ways to do this to a k-element set, so

<P>
|F<sub>k</sub>| = 2<sup>k</sup>

<P>
and thus
<PRE>
              2<sup>k</sup> 
|F|(x) =  &sum;  ----  x<sup>k</sup>
              k!

       = exp(2x)
</PRE>
More generally, if F is &quot;n-colorings&quot;, its generating function is

<PRE>
|F|(x) = exp(nx)
</PRE>
Here's another example that's even simpler.  Suppose G is &quot;being an
n-element set&quot;.  This is such a boring structure that you might never
have thought about it.  There's exactly one way to put this structure on
an k-element set if k = n, and none if k is different from n, so

<PRE>
|G|(x) =  x<sup>n</sup> / n!
</PRE>
You should recognize this function: a while back, I called it the nth
eigenstate of the harmonic oscillator Hamiltonian!  This is cool,
because in physics we often think of this state as one in which there
are n identical bosons present - for example, n photons.  That's why
the harmonic oscillator is also called the &quot;number operator&quot;.   Now
we're seeing that this &quot;n-particle state&quot; is also the generating
function of &quot;being an n-element set&quot;.  So the quantum mechanics of
identical bosons may not be so weird after all.

<P>
The generating function

<PRE>
|F|(x) = exp(nx)
</PRE>
also corresponds to a famous state in Fock space, called a
&quot;coherent state&quot;.  For example, a laser beam is a coherent
state of photons.  If you're curious about the details, see:

<P>
2) John Baez and Michael Weiss, Photons, schmotons, available at
<A HREF = "http://math.ucr.edu/home/baez/photon">http://math.ucr.edu/home/baez/photon</A>

<P>
But don't worry about it too much: my main point is just that it's fun
to take types of structure, work out their generating functions, and
think of these as states in Fock space.  

<P>
To take this a step further, let's see how the creation and annihilation
operators fit into the picture.

<P>
First, since these are linear operators, we should think about how
<em>addition</em> fits into the picture!  In quantum mechanics, adding states
is called &quot;superposition&quot;.  But what about in combinatorics?  What
corresponds to adding generating functions?

<P>
It's very nice.  Given two types of structure, say F and G, we can
define a type of structure F+G by saying an F+G-structure on the set S
consists of either an F-structure on S or a G-structure on S.  This
gives us

<PRE>
|F+G| = |F| + |G| 
</PRE>

which justifies the notation F+G.  It means we can think of F+G as a
&quot;superposition&quot; of structure types.  Of course you might
complain that in quantum mechanics we can do more than add states: we
can also multiply them by complex numbers!  We can't do this with
structure types; we can only multiply those by <em>natural</em> numbers, via
repeated addition.

<P>
So the combinatorics of structures on finite sets is like a bare-bones
version of quantum mechanics, without the complex numbers or even
subtraction.  You might think we're doing quantum mechanics over the
natural numbers, and that's close - but we're actually doing quantum
mechanics over the category of finite sets!   

<P>
To make the idea of &quot;categorified quantum mechanics&quot; really precise,
I'll need to jack up the math level a fair amount.  This may be a bit
scary, so I'll do it later in this article, after everyone has already
stopped reading.

<P>
But now, what about the creation operator?  Since this involves
multiplication, I'd better tell you how to <em>multiply</em> structure types.

<P>
We can define a type of structure FG by saying an FG-structure on S
consists of a way of chopping S into two disjoint subsets and putting an
F-structure on the first subset and a G-structure on the second.  If we
make this definition, we get

<PRE>
|FG| = |F| |G|
</PRE>
I'll let you check this!

<P>
Now let's invent a creation operation A* on structure types that reduces
to the usual creation operator a* when we take their generating
functions.  In other words, we want an operation A* with 

<PRE>
|A*F| = a*|F|
</PRE>
The operator a* is multiplication by x, and we've seen that x is the
generating function of the structure type &quot;being a 1-element set&quot;.   
So if we call that structure type X, the operation

<PRE>
A*F = XF
</PRE>
does what we want.

<P>
But what is A*F really <em>like?</em>

<P>
Well, to put a structure of this type on a set S, we chop it into two
parts, put an X-structure on one part, and put an F-structure on the
other.  So putting an A*F-structure on a set really just means picking 
a point from that set, removing it, and putting an F-structure on what's
left!

<P>
This business about &quot;removing a point&quot; may sound more like
annihilation than creation.  But you can check that if you have an
F-structure on a set with n elements, you get an A*F-structure on a set
with n+1 elements. It's just like how you translate the function f(x) to
the <em>left</em> one notch by forming the new function f(x+1).  You might have
thought that would translate the function to the <em>right</em> - but pushing
points to the right pushes functions to the left.

<P>
So the creation operator really does push the particle number up by one.
In  particular, if we stretch our notation and let |n&gt; stand for the
structure type &quot;being an n-element set&quot;, we get

<PRE>
A*|n&gt; = (n+1) |n+1&gt;
</PRE>
just like we should. 

<P>
The annihilation operator for structure types is similar.  Let's call it
A.  To put an AF-structure on the set S, we pick an extra point, say *,
and put an F-structure on the disjoint union S U {*}.  I'll let you
check that with this definition,

<PRE>
|AF| = a|F|
</PRE>
and

<PRE>
A|n&gt; = |n-1&gt;
</PRE>
as desired.

<P>
The creation and annihilation operators are linear:

<PRE>
 A(F+G) =  AF + AG
A*(F+G) = A*F + A*G
</PRE>
where the equals sign is secretly an isomorphism... you see, we're
categorifying!  We also have an isomorphism

<PRE>
A A* = A* A + 1
</PRE>
which is just a categorified version of 

<PRE>
a a* = a* a + 1,
</PRE>
cleverly rewritten to avoid subtraction.   You should prove this 
yourself!  If you get stuck, the answer is here:

<P>
3) John Baez and James Dolan, From finite sets to Feynman diagrams,
in Mathematics Unlimited - 2001 and Beyond, vol. 1, eds. Bjorn
Engquist and Wilfried Schmid, Springer, Berlin, 2001, pp. 29-50. 
Also available as <A HREF = "http://xxx.lanl.gov/abs/math.QA/0004133">math.QA/0004133</A>.

<P>
... along with lots of other stuff, like the inner product on our
categorified Fock representation - and indeed, a categorification of 
the whole theory of Feynman diagrams.  However, to describe these we 
need to go a bit beyond the concept of &quot;structure type&quot; and
talk about
&quot;stuff types&quot;, which would be too much of a digression here.

<P>
At this point I should mention that the idea of categorifying the Fock
representation was worked out by Jim Dolan and myself in a lengthy
series of coffee-shop conversations.   On the other hand, people have
used generating functions in combinatorics for a long time.  There
are a lot of really fun things you can do with them!  For a nice easy
introduction, try this:

<P>
4)  Ronald L. Graham, Donald E. Knuth, and Oren Patashnik,
Concrete Mathematics: a Foundation for Computer Science, 
2nd edition, Addison-Wesley, Reading, Massachusetts, 1994.

<P>
To dig deeper, try these:

<P>
5) Herbert Wilf, Generatingfunctionology, Academic Press, Boston,
1994. Also available for free at <A HREF = "http://www.cis.upenn.edu/~wilf/">http://www.cis.upenn.edu/~wilf/</A>

<P>
6) Richard P. Stanley, Enumerative Combinatorics, two volumes, 
Cambridge U. Press, Cambridge, 1999.

<P>
However, it was only in the 1980s that Andre Joyal gave a precise
definition of a &quot;structure type&quot; - he called them &quot;especes de structures&quot;,
so English speakers often call them &quot;species&quot;:

<P>
7) Andre Joyal, Une theorie combinatoire des series formelles,
Adv. Math. 42 (1981), 1-82.

<P>
8) Andre Joyal, Foncteurs analytiques et especes de structures, 
in Combinatoire Enumerative, Springer Lecture Notes in Mathematics
1234, Springer, Berlin (1986), 126-159.

<P>
I also urge you to read this excellent book:

<P>
9) F. Bergeron, G. Labelle, and P. Leroux, Combinatorial species and
tree-like structures, Cambridge, Cambridge U. Press, 1998.

<P>
But now let me get to the punchline.  We can talk about structures not
just on finite sets, but on projective spaces over the field with  
q elements, where q is any prime power.  In &quot;<A HREF = "week184.html">week184</A>&quot; I started trying 
to convince you that there is a very fruitful analogy between these.
If V is a n-dimensional vector space over this field, and P(V) is the
projective space consisting of all lines through the origin in V, we
should think of P(V) as a q-deformed version of an n-element set.  For
example, the number of points in P(V) is the q-integer

<PRE>
[n] = 1 + q + ... + q<sup>n-1</sup>
</PRE>

So, let F be any type of structure we can put on a projective space like
this.  Let F<sub>k</sub> stand for the <em>set</em> 
of all ways we can put this structure
on P(V) when V is our favorite k-dimensional vector space.  Let |F<sub>k</sub>| be
the <em>number</em> of all ways we can do this.  Then we can define the
generating function |F| by

<PRE>
              |F<sub>k</sub>| 
|F|(x) =  &sum;  -----  x<sup>k</sup>
              [k]!

</PRE>
Now there's a q-factorial in the denominator! 

<P>
We can add structure types just as before, and get

<PRE>
|F+G| = |F| + |G|
</PRE>
However, we have to multiply them differently.  To put an FG-structure
on P(V), we pick a subspace U of V and put an F-structure on P(U) and
a G-structure on P(V/U).  With this sneaky definition we get

<PRE>
|FG| = |F| |G| 
</PRE>
This only works because there's q-factorial in our definition of
generating function!  

<P>
Now for the new creation and annihilation operators.  To put 
an A*F-structure on P(V), we pick a 1-dimensional subspace L in V
and put an F-structure on P(V/L).  To put an AF-structure on P(V)
we take a 1-dimensional vector space L and put an F-structure on
P(V+L).  Note that these definitions are almost like the old ones!
But now we get the q-deformed commutation relation:

<PRE>
A A* = q A* A + 1
</PRE>
The equation here is really an isomorphism.   

<P>
If we let |n&gt; be the structure of &quot;being the projectivization of an
n-dimensional vector space&quot;, we have

<PRE>
 A|n&gt;  =        |n-1&gt;
A*|n&gt;  =  [n+1] |n+1&gt;
</PRE>
We can also define a Hamiltonian by

<PRE>
H = A* A
</PRE>
and we get

<PRE>
H|n&gt; = [n] |n&gt;
</PRE>
where now the eigenvalues are q-integers.  

<P>
In short, we've categorified the q-deformed Fock representation!

<P>
To wrap up, I'd like to make the underlying category theory in this
story a bit more precise.   I'm afraid I'll have to turn up the math
level a notch now.

<P>
First, here's how Joyal's theory works.   A &quot;structure type&quot; is 
really a functor

<PRE>
F: FinSet<sub>0</sub> &rarr; Set
</PRE>
where FinSet<sub>0</sub> is the groupoid of finite sets and bijections,
and Set is the category of sets and functions.

<P>
So: if you feed F a finite set X it spits out F(X), the set of 
all structures on X of the given type.  For example, if F is the
structure type of &quot;orderings&quot;, F(X) would be the set of all 
orderings of X.

<P>
But also: if you feed your structure type a bijection f: X &rarr; Y,
it spits out a function F(f): F(X) &rarr; F(Y).  This describes how
we can transfer any structure on X to a structure on Y using the
bijection f.  For example, we can use our bijection to turn any 
ordering of X into an ordering of Y.

<P>
There is actually a category of structure types, where the objects 
are functors 

<P>
F: FinSet<sub>0</sub> &rarr; Set

<P>
and the morphisms are natural transformations between these.   I'll 
call this category Set[[x]], because it's really a categorification of 
the set of formal power series with natural number coefficients, N[[x]]. 
But I want to explain exactly what this means!

<P>
In Platonic heaven, there's an enormous chart showing how you can
categorify all sorts of concepts.  It starts out something like this:

<PRE>

   MATHEMATICS BASED ON SETS          MATHEMATICS BASED ON CATEGORIES

            sets                              categories
    functions between sets              functors between categories
 equations between functions       natural isomorphisms between functors

      elements of sets                   objects of categories
 equations between elements           isomorphisms between objects

</PRE>
... and it goes on forever.  In particular, if you look further down
this chart, you'll see that N appears in the left-hand column as the
free commutative rig on no generators, Set appears in the right-hand
column as the free symmetric 2-rig on no generators.

<P>
Huh?

<P>
A &quot;rig&quot; is a &quot;ring but without negatives&quot; - hence the missing letter n.
More precisely, it's a set with two monoid structures, + and x, where +
is commutative and x distributes over +.   We call a rig &quot;commutative&quot; 
if the multiplication is also commutative.  The most important rig of all
is the natural numbers, since this is the free rig on no generators.
It's also the free commutative rig on no generators.

<P>
There are actually different ways to categorify the concept of rig and
get a notion of &quot;2-rig&quot;, but one nice way is to define it as a category
with colimits equipped with a monoidal structure that distributes over
the colimits.  Having colimits is like having addition; the monoidal
structure is like multiplication.  We call a 2-rig &quot;symmetric&quot; if the
monoidal structure is symmetric; this is like being commutative.  The
most important 2-rig of all is the category Set, since this is the free
2-rig on no generators.  It's also the free symmetric 2-rig on no
generators.

<P>
The free commutative rig on <em>one</em> generator is N[x], the rig of 
polynomials in x with natural number coefficients.  We need to do a 
kind of &quot;completion&quot; process, throwing in certain infinite sums, to
get N[[x]], the rig of formal power series in x with natural number
coefficients.  The theory of 2-rigs allows infinite sums automatically,
so the free symmetric 2-rig on one generator is called Set[[x]] - and
this is the category of structure types!  Addition and multiplication
in this 2-rig turn out to work exactly as I've already described.  

<P>
There's a lot more to say about this, but the interesting thing to me
now is that when we q-deform Set[[x]], we get the category of structures
on projective spaces over the field with q elements.  And the <em>really</em>
interesting part is that while this is a monoidal category, it's no
longer symmetric.  However, it's almost <em>braided</em>.  Actually,
Joyal and Street showed this in a related situation, namely where one
considers not a <em>set</em> of structures on a projective space, but a
<em>complex vector space</em> of structures:

<P>
10) Andre Joyal and Ross Street, The category of representations of
the general linear groups over a finite field, Jour. Alg. 176 (1995),
908-945.

<P>
They even show that the braiding satisfies the Hecke relations, familiar
from the theory of the quantum group SL<sub>q</sub>(n)!  This shows there's a
really deep relationship between the q-deformation in the theory of
quantum groups and the strange q-deformation I'm talking about here,
where q is a power of a prime number.  There are indeed other clues
pointing to a relation of this sort, but this seems like the most
fundamental one I've seen so far... and I'm trying to get to the 
bottom of things!  

<P>
I hope the general picture is clear:

<PRE>

  q = 1                         q = a power of a prime number    

  finite sets                   projective spaces over F<sub>q</sub>
  permutation groups S<sub>n</sub>         projective special linear groups PSL(n,F<sub>q</sub>)
  structure types               q-deformed structure types
  Fock representation           q-deformed Fock representation

</PRE>
We're thinking of the groupoid formed by the projective spaces and their
symmetry groups PSL(n,F<sub>q</sub>) as a q-deformed version of the groupoid
formed by the finite sets and their symmetry groups S<sub>n</sub>.   The functors
from these groupoids to Set are &quot;structure types&quot;, and taking generating
functions of these we get the Fock representation.

<P>
In a sense, all this relies on the analogy between the permutation
groups S<sub>n</sub> and the groups PSL(n).   The groups PSL(n) have Dynkin
diagrams like this: 

               
<PRE>

                    o----o----o----o----o----o

</PRE>
and we call this series of Dynkin diagrams the &quot;A&quot; series.  So, you
should wonder if there is a grand generalization of everything I've
said so far to <em>other</em> Dynkin diagrams.  And the answer appears to be:
yes!  

<P>
I'll talk a bit about this next week.

<P>
<HR>
<P>

